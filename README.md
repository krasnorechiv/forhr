# Momo Store aka Пельменная №2

<img width="900" alt="image" src="https://user-images.githubusercontent.com/9394918/167876466-2c530828-d658-4efe-9064-825626cc6db5.png">

№**Описание репозитория**:
Пельменная. Код собирается, компилируется и отправляется в два репозитория - docker-registry и в nexus в виде: бэкэнд - бинарных файлов, фронтенд - в виде тар-архива. Далее, в зависимости от нахождения в ветке - создаётся инфраструктура и автоматически деплоится приложение на сервера. 

# ///**Устройство репозитория**:

## 1 - **backend**: исходники бэкэнда пельменной
### Помимо исходников, содержит в себе Dockerfile
## 2 - **frontend**: исходники фронтенда пельменной
### Помимо исходников, содержит в себе Dockerfile
## 3 - **repo**: исходники ias (ansible terraform)



# ///**Как работать с репозиторием**:
## - Используем для работы с репозиторием git flow. По мере возрастания сложности и объёмности проекта перейдем на gitlab flow.    
## - В репозитории не хранятся никакие чувствительные данные (даже initial logins etc) - пока что все чувствительные данные пишем в переменные gitlab env и ставим атрибут masked (по возможности кодируем в base64). По мере выделения больших средств - перейдём на хранение секретов в Vault
## - Инфраструктура изменяется, создаётся только для main develop веток. По мере возрастания финансовых возможностей будет возможность создавать для каждой ветки, релизных веток свою ВМ.
## - Используем правила версионирования sem-ver. Меняем версию приложения( в gitlab-ci) только тогда, когда готовы закрывать релиз и мерджить с main-веткой



# **Пайплайн сборки, запуска приложения и инфраструктуры**:

## _Заполняем переменные_:

## - Для CI процесса сборки (prepare,build,test): требуется заполнить обязательные переменные:
Создать в Сонаре проект проверки бэкэнда\фронтенда:
    ${SONAR_PROJECT_KEY_BACK}
    ${SONARQUBE_DIR} 
    ${SONARQUBE_URL} 
    ${SONAR_LOGIN}
    ${GO_VERSION}
    ${NODE_VERSION}
 

## - Для CD(delivery) процесса сборки (release-binary, docker-gen-image): требуется заполнить обязательные переменные:
    ${NEXUS_REPO_USER}
    ${NEXUS_REPO_PASS}
    ${NEXUS_REPO_URL}
    ${NEXUS_REPO_FRONTEND_NAME}

----
**Примечение**: после отправки изменений во все ветки кроме main/develop, запустится пайплайн, который соберёт приложение и заботливо отправит бинарники в нексус, докер образы в gitlab-registry
Если делается мердж веток в main или в develop или напрямую в них идут коммиты (что нельзя) то идут шаги по созданию инфры. 
----

## - Для IaS и СD процесса сборки (create-auth, create-machine, connect-to-machine) требуется заполнить обязательные переменные:

    ${YC_OATH_ID} - ключ авторизации для инфры
    ${TF_S3_BUCKET} - имя s3 бакет
    ${TF_STATE_BUCKET} - имя бакета
    ${TF_VAR_cloud_id} - id облака инфраструктуры
    ${TF_VAR_folder_id} - id директории инфраструктуры
    ${SA_NAME} - имя сервисного аккаунта
    ${GRAFANA_LOGIN} - первоначальный логин для grafana
    ${GRAFANA_PASSWD} - первоначальный пароль для grafana
    ${AWS_ACCESS_KEY_ID} - ключ-id для баккета
    ${AWS_SECRET_ACCESS_KEY} - секретный ключ для бакета
    ${SSH_ID_RSA} - base64 ключ ssh для ansible (на время создания инфры)

**Примечание**: 
Этап create-auth создаёт бакет, но надо вручную запросить ключи бакета и передать это gitlab переменные. Наиболее оптимальный вариант - **заранее** определится с именем бакета, создать бакет и скопировать ключи - так как они **показываются один раз при создании**. В скрипте create-auth идёт проверка на наличие бакета, и при наличии он не будет создавать ещё один бакет. Так же в create-auth создаётся публичный бакет для картинок.

В скрипте create-auth передаётся в переменную TF_VAR_token1 iam токен яндекса для terraform.

#Подробное описание

**- Как создаётся инфраструктура:**
После того как отработал этап create-auth-and-bucket и отдал необходимые переменные аутентификации, идёт этап **терраформинга**:

Как происходит **терраформинг**: 
- Для задачи терраформинга выстроены правила срабатывания задачи. Для веток main и develop прописаны переменные, которые в свою очередь задают терраформу имя вм, имя сети, подстраивают окружение
- в конце задачи терраформинга - срабатывает output с переменными

Описание: После старта пайплайна, если будут 


Сборка приложения из исходников и запуск:


## Frontend

```bash
npm install
NODE_ENV=production VUE_APP_API_URL=http://localhost:8081 npm run serve
```

## Backend

```bash
go run ./cmd/api
go test -v ./... 
```

|||Запуск приложений пельменной через контейнеры Docker:
Бэкэнд:
docker run -d image_of_pelmennaya-backend --network pelmennaya-net --network-alias pelmennaya-backend-active
Фронтенд:
docker run -d image_of_pelmennaya-frontened --network pelmennaya-net -p 80:80


```

                      /^--^\     /^--^\     /^--^\
                      \____/     \____/     \____/
                     /      \   /      \   /      \
                    |        | |        | |        |
                     \__  __/   \__  __/   \__  __/
|^|^|^|^|^|^|^|^|^|^|^|^\ \^|^|^|^/ /^|^|^|^|^\ \^|^|^|^|^|^|^|^|^|^|^|^|
| | | | | | | | | | | | |\ \| | |/ /| | | | | | \ \ | | | | | | | | | | |
| | | | | | | | | | | | / / | | |\ \| | | | | |/ /| | | | | | | | | | | |
| | | | | | | | | | | | \/| | | | \/| | | | | |\/ | | | | | | | | | | | |
#########################################################################
| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |
| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |
```